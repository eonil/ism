// Note: Generated by AI assistant
use std::collections::HashMap;
use serde::{Serialize as SerdeSerialize, Deserialize as SerdeDeserialize};
use std::fmt;

#[derive(Debug, Clone, SerdeSerialize, SerdeDeserialize)]
#[serde(untagged)]
pub enum Message {
    Text(MessageText),
    List(MessageList),
    Table(MessageTable),
}

pub type MessageText = String;
pub type MessageList = Vec<Message>;
pub type MessageTable = HashMap<String, Message>;

#[derive(Debug)]
pub enum Error {
    SerdeJson(serde_json::Error),
    InvalidType { expected: &'static str, found: &'static str },
    MissingField(&'static str),
}

impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Error::SerdeJson(e) => write!(f, "JSON error: {}", e),
            Error::InvalidType { expected, found } => {
                write!(f, "Invalid type: expected {}, found {}", expected, found)
            }
            Error::MissingField(field) => write!(f, "Missing required field: {}", field),
        }
    }
}

impl From<serde_json::Error> for Error {
    fn from(err: serde_json::Error) -> Self {
        Error::SerdeJson(err)
    }
}

pub trait Serialize {
    fn serialize(&self) -> Message;
}

pub trait Deserialize: Sized {
    fn deserialize(msg: Message) -> Result<Self, Error>;
}

impl Message {
    pub fn serialize<T: SerdeSerialize>(value: &T) -> Result<String, Error> {
        Ok(serde_json::to_string(value)?)
    }

    pub fn deserialize<T: SerdeDeserialize<'static>>(json: &str) -> Result<T, Error> {
        Ok(serde_json::from_str(json)?)
    }
} 